

***************************** 개발환경설정 *****************************

- 7zip 다운로드 
https://www.7-zip.org/ ( 알집은 경로가 길면 zip 파일 플다가 오류난다. )

- STS 다운 버전 (STS 3.9.9.RELEASE) 다운로드 , 윈도우 ver
https://spring.io/tools3/sts/legacy
\sts-3.9.9.RELEASE\STS.exe -> 실행
* STS4 버전부터는 mvn package 를 market place.. 다운받아야 한다.

- 이클립스 java was started but returned exit code=13 해결 방법
이클립스가 설치 된 경로에 eclipse.ini파일이 있습니다. 
eclipse.ini 실행시킵니다. -> --launcher.appendVmargs 와 -vmargs 사이에 아래의 코드를 입력한다.
==============================================
-vm
C:\Program Files\Java\jdk1.8.0_121\bin\javaw.exe
==============================================

- 이글립스 UTF-8 설정 
window -> General -> Workspace -> UTF-8 설정
Web -> HTML , CSS, JSP 또한 UTF-8 설정

- 프로젝트 생성
File - new - spring lefacy project 선택 - Spring MVC 프로젝트 선택
프로젝트 이름은 'ex00_new' 을 사용하고 , 패키지 이름은 'org.zerock.controller' 로 한다.

- 라이브러리의 초기화
폴더옵션에서 숨김파일을 볼수 있게 설정 후 , 사용자 및에 m2 파일을 볼수 있다.
(메이븐의 레파지토리 폴더) C:\Users\whddb\.m2\repository

- 스프링 버전 5를 사용하기 위해서 pom.xml 변경

	<properties>
		<java-version>1.6</java-version>
		<org.springframework-version>5.0.7.RELEASE</org.springframework-version>
		<org.aspectj-version>1.6.10</org.aspectj-version>
		<org.slf4j-version>1.6.6</org.slf4j-version>
	</properties>


- java version 변경 pom.xml 변경 

	<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.5.1</version>
    <configuration>
        <source>1.8</source>
        <target>1.8</target>
        <compilerArgument>-Xlint:all</compilerArgument>
        <showWarnings>true</showWarnings>
        <showDeprecation>true</showDeprecation>
    </configuration>
	</plugin>

- lombok 라이브러리 설치 

lombok 은 자주 사용하는 getter/setter , tostring() , 생성자 등을 자동으로 생성해 준다.
 * 직접설치 했는데 에러가 나서 아래와 같은 버전으로 pom.xml 에 추가해서 다운로드 받았다. 
 다운로드 받은 m2 위치에 가서 아래의 버전을 다시 실행 후 설치 했다. 
 
 <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.2</version>
    <scope>provided</scope>
</dependency>


- jex00 프로젝트 생성 

xml 이 아닌 java 클래스 파일을 이용하여 스프링관련 설정을 하도록 한다. 

프로젝트 생성 후 아래와 같은 삭제 작업진행 
- xml 파일 삭제 
web.xml , server-context.xml , root-context.xml 
WEB-INF 폴더 아래는 classes 와 views 폴더만 있어야 한다. 

파일을 삭제하면 pom.xml 에 에러가 나는데 아래와 같이 pom.xml 에 내용을 추가해야 한다. 

<plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-war-plugin</artifactId>
        <version>3.2.0</version>
        <configuration>
          <failOnMissingWebXml>false</failOnMissingWebXml>
        </configuration>
      </plugin>


- 변경

<properties>
		<java-version>1.8</java-version>
		<org.springframework-version>5.0.7.RELEASE</org.springframework-version>
		<org.aspectj-version>1.6.10</org.aspectj-version>
		<org.slf4j-version>1.6.6</org.slf4j-version>
	</properties>
	
- 변경 

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>2.5.1</version>
    <configuration>
        <source>1.8</source>
        <target>1.8</target>
        <compilerArgument>-Xlint:all</compilerArgument>
        <showWarnings>true</showWarnings>
        <showDeprecation>true</showDeprecation>
    </configuration>
	</plugin>
	
- 설정파일 생성 
RootConfig.java 를 통해서 root-context.xml 을 대신한다. 
WebConfig.java 를 통해 web.xml 을 대신한다. 
	
---------- 의존성 주입 테스트 (ex00_new) ---------- 

- 라이브러리 추가 

 pom.xml 에 추가 
 
 <!-- 스프링 TEST 위한 라이브러리 -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
		
		<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.2</version>
    <scope>provided</scope>
	</dependency>

 - 변경 
<!-- Test -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency> 		
 
 - 클래스 생성
 
 Chef.java 
 Restaurant.java 
 
 
 --------------- XML 을 이용하는 의존성 주입 설정 
 
 - root-context 에서 Namespace 탭 -> context 체크 , 아래의 source 추가 (xml 을 통해 bean 으로 등록 하는 과정) (ex00_new)
 <context:component-scan
		base-package="org.zerock.sample">
		</context:component-scan>
		
 - java 설정의 경의 ------ root-context 대신 RootConfig 클래스를 이용한다. (jex00)
 RootConfig.java 파일 수정 
 
 - 테스트 코드를 통한 확인 (ex00_new , jex00)
 
 SampleTests.java 를 통해서 테스트 해본다. 
 
 
 - 스프링 4.3 이후에는 묵시적 생성자 주입이 가능하다. 
 
 SampleHotel.java 
 HotelTests.java 
 
 - 오라클 jdbc 테스트 (직접추가 가능하고 , pom.xml 을 이용해서도 추가 가능하다. )
 
 pom.xml , JDBCTests.java 추가 
 
 <repositories>
		 <!-- repositories 제일 밑에 아래의 repository 추가 -->
		<!-- 오라클 repositories -->	
		<repository>
			<id>oracle</id>
			<url>http://maven.jahia.org/maven2</url>
		</repository>
</repositories>
		
		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<version>12.1.0.2</version>
		</dependency>
 
  - 커넥션 풀 설정 , spring-jdbc 라이브러리를 이용하는 방식도 있지만 , 최근에는 HikariCP 라이브러리를 많이 사용중이다. 
  
  pom.xml 추가 
  
  <dependency>
  <groupId>com.zaxxer</groupId>
  <artifactId>HikariCP</artifactId>
  <version>2.7.4</version>
  </dependency> 
		
  root-context 설정 (ex00_new)

 <bean id="hikariConfig" class="com.zaxxer.hikari.HikariConfig">
 <property name="driverClassName"
 value="oracle.jdbc.driver.OracleDriver"></property>
 <property name="jdbcUrl"
 value="jdbc:oracle:thin:@localhost:1521:XE"></property>
 <property name="username" value="book_ex"></property>
 <property name="password" value="book_ex"></property>
 </bean>   
 
 <!-- HikariCP configuration -->
 <bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource"
 destroy-method="close">
 <constructor-arg ref="hikariConfig" />
 </bean> 


 -------- java 설정시 (jex00) 
 
 RootConfig.java 설정 
 
 -- 마이바티스 와 스프링 연동 
 
 - pom.xml 에 추가되는 라이브러리 

 <!-- MyBatis 라이브러리 -->
		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis</artifactId>
			<version>3.4.1</version>
		</dependency>
		
		<!-- 마이바티스와 스프링 연동을 위한 라이브러리 -->
		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis-spring</artifactId>
			<version>1.3.0</version>
		</dependency>
		
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-tx</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
		
		<!-- 스프링에서 JDBC 를 사용하기 위한 라이브러리 입니다. -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
		
		
 - SQL SessionFactory 의 설정 
  root-context.xml 설정 
  
  <!-- HikariCP configuration -->
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource"
destroy-method="close">
<constructor-arg ref="hikariConfig" />
</bean>

<bean id="sqlSessionFactory"
class="org.mybatis.spring.SqlSessionFactoryBean">
<property name="dataSource" ref="dataSource"></property>
</bean>

 
 -- jex00 에서의 설정은 RootConfig 변경 

 테스트는 DataSourceTests.java 를 통해서 한다 .

 - mapper 작성하고 연동 테스트 
TimeMapper.java 추가 후 root-context 에서 mapper 를 인식할수 있도록 설정해 준다. 

namespaces 에서 mybatis-spring 항목을 체크해 준다. 
root-context 에 아래의 내용 추가 
<mybatis-spring:scan base-package="org.zerock.mapper"/>

- jex00 설정은 RootConfig 에서 .. 

TimeMapperTests.java 를 통해 테스트 해본다. 
TimeMapper.java 같은 경우는 interface 만 만들었는데 자동으로 내부적으로 클래스가 만들어 진걸 알수있다.
이에 대한 자세한 설명은 AOP 때 자세히 설명한다. 

- 위와같이 java 자체적으로 쿼리를 처리할수도 있지만 , xml 도 같이 연동이 가능하다. (TimeMapper.xml)
TimeMapper.java 에서 getTime2() 와 같이 xml의 <mapper> 태그와 namespaces 속성값 , 
mapper 인터페이스와 xml 인터페이스 namespaces 속성을 가지고 동일 이름이 존재하면 이를 병합처리한다.
ex) TimeMapper.java = TimeMapper.xml 

- log4jdbc-log4j2 설정 ---------- 
쿼리부분을 자세히 보기위해서 log 를 설정한다. 

pom.xml 설정 
<dependency>
    <groupId>org.bgee.log4jdbc-log4j2</groupId>
    <artifactId>log4jdbc-log4j2-jdbc4</artifactId>
    <version>1.16</version>
</dependency>
?
1. 로그 설정 파일을 추가하는 작업과 
2. jdbc의 연결정보를 수정해야 한다. 

log4jdbc.log4j2.properties 파일 추가 
root-context 의 수정 

 <property name="driverClassName"
      value="net.sf.log4jdbc.sql.jdbcapi.DriverSpy"></property>
    <property name="jdbcUrl"
      value="jdbc:log4jdbc:oracle:thin:@localhost:1521:orcl"></property>
 
 - java 설정은 RootConfig 에서 설정 
 
 
---- log 의 레벨 설정은 log4j.xml 에서 해 줄수 있습니다. 테스트 코드에 관련된 로그는 
src/test/resources 밑에 있는 log4j.xml 파일을 변경해 줘야 합니다. 

기복적인 설정은 info 이지만 warn 과 같이 좀더 높은 레벨로 설정하면 로그의양이 줄어드는걸 확인할수 있다. 

log4j 에서 에러가 날때는 아래와 같이 변경해 주면 된다. 

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE log4j:configuration SYSTEM "http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/xml/doc-files/log4j.dtd">
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">



 ********************************* part2 ***** 스프링 MVC 설정 ************** ( ex01_new , jex01 )
 
 ------- 스프링 MVC 의 기본 구조 
 
 -xml 설정 구조 
 spring MVC = server-context.xml 
 Spring Core , MyBatis = root-context.xml 
 - 자바 설정 구조 
 spring MVC = servletConfig.class
 Spring Core , MyBatis = RootConfig.class

의미로는 root-context 는 일반 자바 영역과 server-context 로 설정하는 WEB 영역을 같이 연동해서 구동한다. 

- 자바설정 등을 이용하려면 서블릿 3.0 이상을 사용하는것이 좋다. 
pom.xml 수정 

<dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
    </dependency>

- 자바설정에서는 ServletConfig.java 파일로 server-context 의 설정을 대신한다. 

- WebConfig.java 설정을 통해서 mvc 기본정로도 '/' 설정되어야 한다. 

web.xml 은 tomcat 구동과 관련된 설정이고 , root-context 와 server-context 는 스프링에 관련된 설정 파일이다. 
프로젝트의 구동은 web.xml 에서 시작된다. 상단에는 가장 먼저 구동되는 context listener 가 등록되어 있다. 
그외의 root-context 의 경로와 url-pattern 등 여러가지 설정을 하게된다. 

스프링의 기본사상은 HttpServletRequest/HttpServletResponse 등과 같은 servlet/jsp API 를 사용할 필요성이 현저하게 줄어든다. 
(스프링이 중간역할을 해준다)

------------- 스프링 MVC 의 controller --- 

- @Controller, @RequestMapping

SampleController.java 를 생성한다. 
위에서 사용하는 @Connector 를 사용하면 자동으로 bean 에 등록이 되는데 , server-context 에 스캔설정이 돼 있어야 한다. 
스캔이 되면 클래스(java파일) 옆에 조그만하게 s 표시가 생긴다. 

 @RequestMapping 같은 경우는 기본적으로 URL 의 경로가 된다. 
 SampleController 에서는 @Log4j 를 사용하는데 , @Log 를 이용하는데 반해  Log4j 라이브러리를 사용한다. 
 
 - @Log4j 에러 발생시 
 pom.xml에서 <scope>runtime</scope>를 주석처리 해주면 된다.
 
 - @RequestMapping 의 변화 , 축약형 표현으로 @GetMapping 과 @PostMapping 이 스프링 4.3 버전부터 추가됐다. 
 SampleController.java 통해 테스트 한다. 
 일반적으로 get 과 post 방식만 사용하지만 최근에는 put,delete 방식 등도 많이 사용된다. 
 @GetMapping 같은 경우는 오직 get 방식만 사용할 수 있으므로 간편하지만 제한은 많은 편이다. 
 
 - controller 의 파라미터 수집 
controller 의 가장편한 기능은 자동으로 파라미터가 수집된다는것 이다. 
예제를 위해 SampleDTO 클래스를 작성한다. 테스트 
http://localhost:8080/sample/ex01?name='AAAAA'&age=100
http://localhost:8080/sample/ex02?name='AAAAA'&age=100
http://localhost:8080/sample/ex02List?ids='AAAAA'&ids=BBB
http://localhost:8080/sample/ex02Array?ids='AAAAA'&ids=BBB

http://localhost:8080/sample/ex02Bean?list[0].name=aaa&list[1].name=bbb = [] 부분이 특수문자로 허용안되는경우가 많다. 그래서 아래와 같이 변경
http://localhost:8080/sample/ex02Bean?list%5B0%5D.name=aaa&list%5B3%5D.name=bbb 

- @initBinder 
피라미터를 수집할때 변환이 가능한 데이터는 자동으로 변환시켜주는 기능이다. 
- @initBinder 사용시
http://localhost:8080/sample/ex03?title=test&dueDate=2020-10-21
- @initBinder 사용안하고 , 파라미터로 사용되는 인스턴스 변수에 @DateTimeFormat 통해서도 가능하다. 
위와 같은경우에는 @initBinder 가 없어도 된다. (인스턴스 자체적으로 처리하려면 @initBinder를 주석처리해야한다.)
http://localhost:8080/sample/ex03?title=test&dueDate=2020/10/21


 - Model 데이터 전달 
getter/setter 를 가진 클래스의 경우 자도응로 controller 에서 화면(view)까지 자동으로 전달된다. 
전달될 때에는 앞글자는 소문자로 처리된다. 반면에 기본 자료형은 파라미터로 선언하더라도 화면까지 전달되지는 않는다. 
하지만 @ModelAttribute("test") 를 사용하면 강제로 전달받은 피라미터를 model 에 담아서 전달하도록 한다. 
http://localhost:8080/sample/ex04?name=aaa&page=99

 - RedirectAttributes
 일회성으로 데이터를 전달하는 용도로 사용된다. 
 ex) 
rttr.addFlashAttribute("name", "AAA");
rttr.addFlashAttribute("age", 10);
return "redirect:/";

- Controller의 리턴 타입 
어노테이션을 사용하는 방식으로 변한 이후에 가장 큰 변화는 리턴 타입이 자유로워 졌다는 것이다. 
String : jsp 경로
void : 호출하는 URL 과 동일한 이름의 jsp 
VO , DTO 타입 : 주로 JSON 타입의 데이터를 만들어서 반환하는 용도로 사용
ResponseEntity 타입 : response할 때 Http 헤더 정보와 내용을 가공하는 용도로 사용 (추가적인 라이브러리 필요). 
Model, ModelAndView : Model로 데이터를 반환하거나 화면까지 같이 지정하는 경우에 사용 (최근에는 많이 사용하지 않습니다.). 
HttpHeaders : 응답에 내용 없이 Http 헤더 메시지만 전달하는 용도로 사용 

- void 테스트 
http://localhost:8080/sample/ex05
설정은 server-context 값을 참조한다. 

- String 테스트 
HomeController.java 참조 

- 객체타입 
주로 JSON 타입 .. pom.xml 에 라이브러리 추가 
pom.xml 
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.4</version>
</dependency>

http://localhost:8080/sample/ex06


- ResponseEntity 타입 
http://localhost:8080/sample/ex07

- 파일 업로드 처리 
Servlet 3.0 (tomcat 7.0) 이후 기본적으로 업로드되는 파일을 처리할 수 있는 기능이 추가되어 있다. 
하지만 Spring Legacy Project 로 생성된 프로젝트의 경우는 Servlet 2.5 를 기준으로 생성되기 때문ㅁ에 3.0 이후 지원은 어렵다. 
3.0 이상의 파일 업로드 방식은 후반부에 다룬다. 그래서 commons-fileupload 를 이용한다. 
pom.xml 에 추가 
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.3.3</version>
</dependency>

추가될 폴더를 임시로 작성한다. (server-context)
<beans:bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
    <beans:property name="defaultEncoding" value="utf-8"></beans:property>
    <!-- 1024 * 1024 * 10 bytes  10MB -->
    <beans:property name="maxUploadSize" value="104857560"></beans:property>
    <!-- 1024 * 1024 * 2 bytes  2MB -->
    <beans:property name="maxUploadSizePerFile" value="2097152"></beans:property>
    <beans:property name="uploadTempDir" value ="file:/C:/spring_file/upload"></beans:property>
    <beans:property name="maxInMemorySize" value="10485756"></beans:property>
  	</beans:bean> 

http://localhost:8080/sample/exUpload

-------- java 설정 이용시 ------
ServletConfig.java 에 설정 

- 컨트롤러의 예외(Exception)처리 
@ExceptionHandler와 @ControllerAdvice를 이용한 처리 
@ResponseEntity를 이용하는 예외 메시지 구성 

- @ControllerAdvice
AOP 를 이용하는 방식이다. 
CommonExceptionAdvice.java
위의 내용에서 @ControllerAdvice 는 컨트롤러에서 발생하는 예외를 처리하는 존재임을 명시하는 용도 
@ExceptionHandler 는 해당 메서드가 () 들어가는 예외 타입을 처리한다. 속성으로 Exception.class 를 지정하여서 모든 예외 처리가 except() 에서만 처리할 수 있다. 

만일 구체적인 예외클래스를 지정하고 싶다면 , jsp 화면에서도 구체적인 메시지를 보고 싶다면 , 
Model 을 이용해서 전달하는 것이 좋다. exception 패키지는 server-context 에서 인식하지 않기 때문에 
<component-scan> 을 이용해서 패키지의 내용을 조사하게 해야 한다. 

server-context 에 추가 
<context:component-scan base-package="org.zerock.exception" />
error_page.jsp 도 추가한다. 
http://localhost:8080/sample/ex04?age=abc&page=99

------ java 설정 이용시 - 

ServletConfig.java 파일에 아래와 같이 패키지 인식시켜 준다 .
@ComponentScan(basePackages = { "org.zerock.controller", "org.zerock.exception" })


- 404 에러 처리 
404 에러 처리 같은경우는 조금 다르게 처리하는것이 좋다. 
서블릿이나 jsp 를 이용했던 개발 시에는 web.xml 을 이용해서 별도의 에러 페이지를 지정할수 있다. 
custom404.jsp 를 추가한다. 
/sample/.. 은 SampleController 가 무조건 동작하기 때문에 다른 경로로 테스트가 필요하다. 
http://localhost:8080/sampleTest/ex004

--------- java 설정 시 ---
webConfilg.java 설정 
@Override
protected void customizeRegistration(ServletRegistration.Dynamic registration) {
	registration.setInitParameter("throwExceptionIfNoHandlerFound", "true");
}


********************************* part3 ***** 기본적인 웹 게시물 관리 ************** ( ex02_new , jex02 )

- 테이블 생성과 더미 데이터 생성 

create sequence seq_board;

create table tbl_board (
  bno number(10,0),
  title varchar2(200) not null,
  content varchar2(2000) not null,
  writer varchar2(50) not null,
  regdate date default sysdate, 
  updatedate date default sysdate
);

alter table tbl_board add constraint pk_board 
primary key (bno);

insert into tbl_board( bno , content , title , writer )
values(SEQ_BOARD.nextval,'테스트 내용','테스트 제목','user00');

-------- 영속계층의 CRUD 구현 ----------

- vo 작성 
BoardVO.java 추가 

- mapper 인터페이스와 mapper XML 
root-context , RootConfig.java : mybatis-spring:scan 추가 
BoardMapper.java 추가 
BoardMapper.xml 추가 (xml 없이 BoardMapper.java 자체적으로도 @ 를 사용해 쿼리를 할수 있다. )

BoardMapperTests.java 를 통해 CRUD 를 테스트 한다. 

-------- 비즈니스 계층 

- service 패키지 추가 
BoardServiceImpl.java 에서 중요한 부분은 @Service 라고 명시를 해주는 것 이다. @AllArgsConstructor 를 통해 BoardMapper 를 주입받는 생성자가 만들어 진다. 
@AllArgsConstructor 를 주입하면 @Setter(onMethod_ = { @Autowired }) 부분을 생략할 수 있다. 

- 스프링의 서비스 객체 설정(root-context)
namespaces 에서 context 항목을 추가해주고 , mybatis-spring:scan 부분 또한 추가해 준다. 
<context:component-scan base-package="org.zerock.service"/>

- java의 설정은 RootConfig 에서 해준다. 
@ComponentScan(basePackages= {"org.zerock.service"})

- service 의 테스트는 
BoardServiceTests.java 를 통해서 한다. 

------ 프리젠테이션(웹) 계층의 CRUD 구현 --------

- Controller 의 작성 
- BoardController 의 작성 
BoardControllerTests.java 를 통해서 테스트 
위의 java 를 통해서 was 의 구동없이 테스트가 가능하다. 
@WebAppConfiguration 부분은 servletContext 를 이용할수 있다. 

BoardControllerTests.java 를 통해서 동록 , 조회 


------- 화면처리 ---------- 
- 화면다운로드
https://startbootstrap.com/themes/sb-admin-2/

아래와 같이 설정값이 view 밑에 jsp 를 찾게 돼 있으므로 , view/board 폴더에 list 를 참조하게 된다. 
http://localhost:8080/controller/board/testList

--- 부트스트렙 적용하기 
경로를 / 로 변경해 준후 
/board/list 페이지를 다운받은 tables.html 의 내용으로 변경해 준다. 

그리고 CSS와 JS 는 브라우저의 개발자 도구를 통해서 확익하며 진행한다. 
다운받은 부트스트렙의 CSS 경로는 http://localhost ..... 로 돼 있기 때문에 제대로 서비스되지 않는다. 
servlet-context 의 설정파일에서 정적인 파일들은 /resources/ 로 지정하고 있다. 
부트스트랩의 모든 폴더를 /resources 에 복사해 준다. 
그리고 list.jsp 에서 경로를 잡아주도록 한다. 
../ 의 경롤를 /resources/ 와 같이 절대경로로 변경해 준다. 

---- includes 적용

html 의 중복을 피하기위해 JSP의 include 지시자를 활용해서 페이지 제작 시에 필요한 내용만 작성하도록 작업해야한다. 
현재 views 폴더에 includes 폴더를 작성하고 , header.jsp 와 footer.jsp 를 선언한다. 

- header.jsp 적용
id : page-wrapper 밑으로 핵심적인 페이지의 내용이므로 윗부분을 잘라서 <%include .. 처리를 해준다.> 

- footer.jsp 적용 
id : page-wrapper 밑으로는 footer 처리 해준다. 
<%@include file="../includes/footer.jsp" %>

- jquery 라이브러리 변경 
jquery 라이브러리가 footer에 포함되 있기 때문에 header.jsp 로 변경해 줘야한다. (이동)

- 반응형 웹 처리 
jquery 를 최신으로 추가해 준후에는 반응형으로 동작하지 않는 문제가 발생한다. 
footer.jsp 에 아래와 같은 코드를 추가해 준다. 

- 화면목록처리 , list.jsp 에는 JSTL 의 출력과 포맷을 적용할 수 있는 태그 라이브러리 추가한다. 

- 등록입력 페이지와 등록처리 
BoardController 에 내용 추가 및 register.jsp 추가 
text 의 속성 name 을 vo 와 맞춰준다.
등록 시 "도배"를 막기위해 redirect 처리를 해줘야 한다. (BoardController)
http://localhost:8080/board/register 


- 한글깨짐 처리 
web.xml 에 인코딩처리
java 는 -> webConfilg 에 처리 

- 상세보기 화면 
get.jsp 추가 
새로운창으로 보여주고 싶으면 , target 속성을 _blank 로 지정해 준다. 

- 뒤로가기 문제 해결
뒤로가기를 하면 데이터가 남아 있거나 , 모달이 다시 나타나는경우등이 있다. 
이럴땐 스크립트에서 window.history 객체를 조작해서 해결하도록 한다. 

- 수정, 삭제처리 
modify.jsp 를 추가해서 
전체적인 CRUD 를 테스트 해본다. 


--------- 오라클 데이터베이스 페이징처리 ---------
오라클에서 INDEX 의 계념은 '이미정렬이 돼 있다는 것 ' ORDER BY 는 성능을 많이 저하되게 만들기 때문에 INDEX 를 쓰는것이 좋다.
- 오라클에서 힌트라는것을 사용해서 컨트롤을 할수 있다. 
힌트 구문은 '/*+' 로시작 하고 '*/' 로 마무리 된다. 

- mybatis 와 스프링에서 페이징처리 , 검색처리 
jex02 , ex02_new 에서 모두 처리 



********************************* part4 ***** REST 방식으로 전환 ************** ( ex03_new , jex03 )

- 어노테이션 
@RestController
Controller가 REST 방식을 처리하기 위한 것임을 명시합니다.

@ResponseBody
일반적인 JSP와 같은 뷰로 전달되는 게 아니라 데이터 자체를 전달하기 위한 용도 

@PathVariable
URL 경로에 있는 값을 파라미터로 추출하려고 할 때 사용 

@CrossOrigin
Ajax의 크로스 도메인 문제를 해결해주는 어노테이션

@RequestBoby
JSON 데이터를 원하는 타입으로 바인딩 처리

--- jackson 라이브러리 추가 
 <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.9.6</version>
    </dependency>

<dependency>
      <groupId>com.fasterxml.jackson.dataformat</groupId>
      <artifactId>jackson-dataformat-xml</artifactId>
      <version>2.9.6</version>
    </dependency>

 <dependency>
      <groupId>com.google.code.gson</groupId>
      <artifactId>gson</artifactId>
      <version>2.8.2</version>
    </dependency>


- 단순 문자열 테스트 
http://localhost:8080/sample/getText

- 객체의 반환 테스트 
@AllArgsConstructor -> 모든 속성을 사용하는 생성자 
@NoArgsConstructor -> 속성 사용하지 않는 생성자 
http://localhost:8080/a/sample/getSample (xml타입)
http://localhost:8080/sample/getSample.json (json타입)

produces 속성 생략가능 테스트 
http://localhost:8080/a/sample/getSample2
http://localhost:8080/a/sample/getSample2.json

- 리스트 
http://localhost:8080/a/sample/getList
http://localhost:8080/a/sample/getList.json

- map
http://localhost:8080/a/sample/getMap
http://localhost:8080/a/sample/getMap.json


- 중간에 들어간 값을 얻기 위해 사용되는 애노테이션
@PathVariable
http://localhost:8080/sample/product/cat/123


-  @RequestBody (객체 파라미터로 보내기)
http://localhost:8080/a/sample/ticket
의 테스트를 해야 하지만 post 방식으로 전달해야 한다. 

------ REST 방식의 테스트 
SampleControllerTests.java 를 통해서 postman 같은 부분없이 JUnit 기반으로 테스트가 가능하다. 


---------- AJAX 댓글 처리 
- 테이블 생성 
create table tbl_reply (
  rno number(10,0), 
  bno number(10,0) not null,
  reply varchar2(1000) not null,
  replyer varchar2(50) not null, 
  replyDate date default sysdate, 
  updateDate date default sysdate
);

create sequence seq_reply;

alter table tbl_reply add constraint pk_reply primary key (rno);

alter table tbl_reply  add constraint fk_reply_board  
foreign key (bno)  references  tbl_board (bno); 
 
- 클래스 추가 
ReplyVO.java 
ReplyMapper.xml
ReplyController.java
ReplyService.java
ReplyServiceImpl.java

- CRUD 작업 

보통은 js 파일을 모듈화 시켜서 사용한다. (관련 있는 함수를 함곳에 모은다)
reply.js 생성 
get.jsp 에 인클루드 시켜준다. 

- postbox 로 테스트 
- 댓글작성 
http://localhost:8080/replies/new 
{   "bno": "2",  "reply": "hello",  "replyer": "테스트댓글1"}

/삭제 /조회
.......... 

전체 CRUD 를 화면에서 테스트 해본다. 


********************************* part5 ***** AOP 와 트랜잭션 ************** ( ex04_new , jex04 )

- 보통 AOP 에서 처리하는 일은 공통으로 처리하는 일로 , 기존의 코드를 수정하지 않고 
파라미터가 올바르게 들어왔는가 ? 작업을 하는 사용자가 적절한 권한을 가졌는가 ? 작억의 예외처리는 어떻게 처리해야 하는가 ?

Before Advice : Target의 JoinPoint를 호출하기 전에 실행되는 코드입니다. 코드의 실행 자체에는 관여할 수 없습니다.
After Returning Advice : 모든 실행이 정상적으로 이루어진 후에 동작하는 코드입니다. 
After Throwing Advice : 예외가 발생한 뒤에 동작하는 코드입니다.
After Advice : 정상적으로 실행되거나 예외가 발생했을 때 구분 없이 실행되는 코드입니다.
Around Advice : 메서드의 실행 자체를 제어할 수 있는 가장 강력한 코드입니다. 직접 대상 메서드를 호출하고 결과나 예외를 처리할 수 있습니다. 

- Pointcut : Advice를 어떤 JoinPoint에 결합할 것인지를 결정하는 설정

execution(@execution) : 메서드를 기준으로 Pointcut을 설정합니다. 
within(@within) : 특정한 타입(클래스)을 기준으로 Pointcut을 설정합니다. 
this : 주어진 인터페이스를 구현한 객체를 대상으로 Pointcut을 설정합니다. 
args(@args) : 특정한 파라미터를 가지는 대상들만을 Pointcut으로 설정합니다. 
@annotation : 특정한 어노테이션이 적용된 대상들만을 Pointcut으로 설정합니다. 

----- AOP 실습

- pom.xml 에 라이브러리 추가 
<dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjrt</artifactId>
      <version>${org.aspectj-version}</version>
    </dependency>

<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
    <dependency>
      <groupId>org.aspectj</groupId>
      <artifactId>aspectjweaver</artifactId>
      <version>${org.aspectj-version}</version>
    </dependency>

 
- 서비스 계층 설계 
SampleService.java
SampleServiceImpl.java

- Advice 작성
loh 는 핵심기능은 아니나 필요한 기능이다. 
LogAdvice.java 

@Aspect 애노테이션 추가 
@Component 는 AOP 상관없지만 , 빈으로 인식하기 위해서 사용한다. 

- AOP 설정
root-context , 네임스페이스에서 aop 와 context 추가 
- 내용추가 
<context:annotation-config></context:annotation-config>

  <context:component-scan
    base-package="org.zerock.aop"></context:component-scan>

  <aop:aspectj-autoproxy></aop:aspectj-autoproxy>
 
- 자바설정 , RootConfig 설정 
@ComponentScan(basePackages="org.zerock.aop")
@MapperScan(basePackages= {"org.zerock.mapper"})
@EnableAspectJAutoProxy


- AOP 테스트 
SampleServiceTests.java
에러처리 , 순서 , 제일강력한 @Around 등을 테스트 해본다. 

----- 스프링에서의 트랜잭션 관리 

- root-context - namespaces 에서 tx 체크해 준다. 아래의 내용추가 

<bean id="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>	

<tx:annotation-driven />
<aop:aspectj-autoproxy></aop:aspectj-autoproxy>

위와 같이 추가해 주면 어노테이션을 추가하는 방식으로 설정을 할수 있다. 

- java 설정 이용 (애노테이션 추가와 빈 등록)

@EnableTransactionManagement 

 @Bean
	  public DataSourceTransactionManager txManager() {
	      return new DataSourceTransactionManager(dataSource());
	  }

- 예제 태이블 생성 및 테스트 SOURCE 추가 
CREATE TABLE TBL_SAMPLE1 (COL1 VARCHAR2(500));
CREATE TABLE TBL_SAMPLE2 (COL2 VARCHAR2(50));
Sample1Mapper.java
Sample2Mapper.java
SampleTxService.java
SampleTxServiceImpl.java

SampleTxServiceTests.java 를 통해 테스트 
@Transactional 를  service 에 추가하면 사용가능 


----- 댓글과 댓글 수에 대한 처리 

-  테이블 수정
alter table tbl_board add (replycnt number default 0);
update tbl_board set replycnt = (select count(rno) from tbl_reply where tbl_reply.bno = tbl_board.bno);

- source 수정 
BoardVO , BoardMapper 수정 

- ReplyServiceImpl.java 의 트랜잭션 처리 
- list.jsp 파일 수정 

http://localhost:8080/board/list


----------- 파일 업로드 처리 
가장 일반적 설정은 commons-fileupload 이지만 tomcat7 버전 
이후에는 서블릿 3.0 이상을 지원하므로, 예제에서는 이를 활용한 방식 사용

서블릿 3.0을 사용하려면 pom.xml 에 버전을 맞춰준다. 
<dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
    </dependency>
	
- web.xml 설정 
web.xml 파일 또한 기본적으로 2.5 버전을 사용하기 때문에 변경해야 한다. 
이와 같은 설정은 WAS 자체의 설정이고 , 스프링에서 업로드 처리는 
MultipartResolver 라는 타비의 객체의 빈으로 등록해야 한다. 
server-context.xml 을 이용해서 설정한다. 

-- 자바설정 이용하는 경우 
WebConfig.java 수정

- form 방식의 파일 업로드 (파일 추가)
UploadController.java  
uploadForm.jsp
http://localhost:8080/uploadForm

IE 에서는 getOriginalFileName( ) 의 결과가 조금 다르게 나온다. 
파일의 이름이 나오지 않고 , 전체 경로가 출력된다. 
IE 처리는 마지막에 경로까지 잘라낸 문자만을 취해야 하는데 , 이에 대한 처리는 AJAX 처리 시 알아보도록 한다.

- Ajax 를 이용한 파일 업로드 
제이쿼리 사용시 아래의 옵션은 반드시 false 여야한다. 
processData: false,
contentType: false,

-- 그외에 파일 전송시 고려 사항들 
-동일한 이름으로 파일이 업로드 된다면 기존 파일이 사라지는 문제 
-이미지 파일의 경우에는 원본 파일의 용량이 큰 경우 섬네일 이미지를 생성해야 하는 문제 
-이미지 파일과 일반 파일을 구분해서 다운로드 혹은 페이지에서 조회 하도록 처리하는 문제
-첨부파일 공격에 대비하기 위한 업로드 파일의 확장자 제한 

----------- 파일 업로드 상세처리 
첨부파일을 이용하는 웹공격을 막기위해 특정한 확장자를 제외한다. 
예제는 exe, sh, zip 등의 경우에는 업로드 제한 , 특정 크기 이상의 파일 제한 처리한다. 
제한처리는 JavaScript로 처리한다.

uploadAjax.jsp 에서 처리 

- 중복된 이름의 첨부파일 처리 
첨부파일 저장시 신경쓰이는것은 크게 두가지로 중복된 이름처리와 , 한 폴더 내에 많은 파일의 생성 문제이다.
- 년원일 폴더의 생성 , 랜덤이름생성
UploadController.java 에서 처리한다. 


------- 섬네일 이미지 생성 
보통 사진은 썸네일 처리를 하지 않으면 , 모바일 환경에서 많은데이터를 소비해야 하므로 특별한 경우를 제외하고는 섬네일을 제작한다. 
제작방법은 여러가지가 있다. JDK 1.4 부터는 ImageIO 를 제공한다
JDK의 ImageIO를 이용할 수도 있지만, 해상도 등의 문제로 인해 별도의 라이브러리 활용
- Thumbnailator 라이브러리 활용 
- pom.xml 추가 
<dependency>
      <groupId>net.coobird</groupId>
      <artifactId>thumbnailator</artifactId>
      <version>0.4.8</version>
    </dependency>

1. 업로드 파일이 이미지 종류인지 판단
2. 이미지파일이면 섬네일 생성 

- 이미지 파일 판단
UploadController.java
checkImageType 메서드 

- 업로드된 파일의 데이터 반환 
.업로드된 파일의 이름과 원본 파일의 이름 
.파일이 저장된 경로 
.업로드된 파일이 이미지인지 아닌지에 대한 정보 

- 정보들을 객체로 처리하고 JSON으로 전송 
AttachFileDTO.java 추가 


---- 브라우저에서 섬네일 처리 

1.업로드 후에 업로드 부분을 초기화 시키는 작업
2.결과 데이터를 이용해서 화면에 섬네일이나 파일 이미지를 보여주는 작업 

- <input type='file'> 의 초기화 
연속으로 파일 업로드 및 업로드된 이미지의 섬네일을 화면에 처리하기위해서 ..
input file 타입은 readlonly라 안쪽의 내용을 수정할수 없기 때문에 별도의 방법을 사용해야 한다. 
아무 내용이 없는 객체를 만들어 업로드한 뒤에는 넣어주는 방식이다. 


----- 첨부파일의 다운로드 혹은 원본 보여주기 
첨부파일의 다운로드는 서버에서 MIME 타입을 다운로드 타입으로 지정하고 , 적절한 헤더 메시지를 통해서
다운로드 이름을 지정하게 처리한다. 

- uploadController 참조 
APPLICATION_OCTET_STREAM_VALUE 등을통해 다운로드 가능하게 지정하고 , 
Content-Disposition 를 이용해서 다운로드시 이름을 지정한다. 
* 첨부파일시 IE 에서는 한글 이름이 제대로 다운로드 되지 않는다 
Content-Disposition 의 처리 방식이 IE 는 다르기 때문이다.
HTTP 헤더 메시지 중에서 디바이스 정보를 알 수 있는 헤더는 'User-Agent'값을 이용한다. 

- 업로드된후 다운로드 처리 
uploadAjax.jsp 참조 

- 첨부파일 삭제 
.이미지 파일의 경우에는 섬네일까지 같이 삭제되어야 하는 점 
.파일을 삭제한 후에는 브라우저에서도 섬네일이나 파일 아이콘이 삭제되도록 처리하는 점 
.비정상적으로 브라우저의 종료 시 업로드된 파일의 처리 

- 첨부파일 삭제의 고민 
.첨부파일은 삭제했지만, 원래의 게시글을 수정/삭제하지 않은 경우 
.비정상적으로 수정/삭제 중에 브라우저가 종료된 경우 
.무난한 방식은 DB에 있는 첨부파일의 목록과 실제 업로드 폴더에 있는 파일의 목록을 비교해서 처리하는 작업을 주기적으로 처리 
.Quartz라이브러리를 이용해서 스프링에서 주기적으로 처리

------- 프로젝트의 첨부파일 - 등록 

- 테이블 추가 
create table tbl_attach ( 
  uuid varchar2(100) not null,
  uploadPath varchar2(200) not null,
  fileName varchar2(100) not null, 
  filetype char(1) default 'I',
  bno number(10,0)
);
alter table tbl_attach add constraint pk_attach primary key (uuid); 
alter table tbl_attach add constraint fk_board_attach foreign key (bno) references tbl_board(bno);

- 객체추가 
BoardAttachVO.java
BoardVO.java
BoardAttachMapper.java
register.jsp
등등 연관된 모든 객체들 수정 및 추가한다. 

- 게시물의 조회와 첨부파일 
- 게시물의 삭제처리 
- 게시물 수정과 첨부파일 
-- 잘못 업로드된 파일 삭제 
-첨부파일정보와 DB상의 정보가 일치하지 않는 상황
.첨부파일만을 등록하고 게시물을 등록하지 않았을 때의 문제 - 파일은 이미 서버에 업로드되었지만, 게시물을 등록하지 않았으므로 의미 없이 파일들만 서버에 업로드된 상황 
.게시물을 수정할 때 파일을 삭제했지만 실제로 폴더에서 기존 파일은 삭제되지 않은 문제 ? 데이터베이스에는 기존 파일이 삭제되었지만, 실제 폴더에는 남는 문제 
.어제 날짜로 등록된 참부파일의 목록 구함 -> 어제 업로드 되었지만 , 데이터베이스에는 존재하지 않는 파일 찾는다. -> 비교해서 필요없는 파일 삭제 

---- Quartz 라이브러리 설정 
-pom.xml 에 라이브러리 추가 
<!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz -->
  <dependency>
    <groupId>org.quartz-scheduler</groupId>
    <artifactId>quartz</artifactId>
    <version>2.3.0</version>
  </dependency>

<!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz-jobs -->
  <dependency>
    <groupId>org.quartz-scheduler</groupId>
    <artifactId>quartz-jobs</artifactId>
    <version>2.3.0</version>
  </dependency>
  
- Quartz 의 설정은 xml 과 어노테이션을 활용할 수 있다. 
어노테이션 사용하기 위해서는 root-context.xml 일부를 수정한다. 
namespaces 에서 task 항목체크 
<context:component-scan
    base-package="org.zerock.task"></context:component-scan>
<task:annotation-driven/>
내용추가 

- 자바설정시 
RootConfig 수정 
@EnableScheduling 추가한다. 
@ComponentScan(basePackages="org.zerock.task")

- Task 작업의 처리 
task 패키지 추가 
@Component 과 @Scheduled 이 추가되어서 사용가능하다. 



********************************* part7 ***** Spring Web Security 이용한 로그인 처리 ************** ( ex06_new , jex06 )

일반 필터와 스프링 인터셉터의 차이는 인터셉터는 스프링의 컨텍스트 내에 있는 모든 자원을 활용할 수 있다는것 이다. 
스프링 시큐리티를 이용하게 되면 인터셉터와 필터를 이용하면서 별도의 컨텍스트를 생성해서 처리하게 된다. 
스프링 스큐리티는 컨텍스트 내에서 동작하기 때문에 이미 컨텍스트에 포함된 여러 빈들을 같이 이용해서 다양한 방식의 인증 처리가 가능하도록 설계가능하다. 

- 설정
- pom.xml 추가 
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-config</artifactId>
    <version>5.0.6.RELEASE</version>
</dependency>
?
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-core</artifactId>
    <version>5.0.6.RELEASE</version>
</dependency>
?
<!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-taglibs -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-taglibs</artifactId>
    <version>5.0.6.RELEASE</version>
</dependency>

- security-config.xml 생성 
시큐리티는 단독으로 설정 할 수 있기 때문에 기존의 root-context.xml 이나 server-context 와는 별도로 작성하는 것이 좋다. 
security-context.xml 추가 후 namespaces 에서 security 항목체크해 준다. 
설정시 5.0버전의 네임스페이스는 문제가 발생하기 때문에 수정해야 한다. 

- web.xml 설정 
시큐리티가 스프링 mvc 에서 사용되기 위해서는 필터를 이용해서 스프링 동작에 관여하게 설정해야한다. 
필터처리와 , security-config 을 로딩하는 작업을 처리해 준다. 

- 시큐리티가 필요한 URI 설계 
/sample/all -> 로그인을 하지 않은 사용자도 접근 가능한 URI 
/sample/member -> 로그인 한 사용자들만이 접근할 수 있는 URI
/sample/admin -> 로그인 한 사용자들 중에서 관리자 권한을 가진 사용자만이 접근할 수 있는 URI

- 인증과 권한부여 
SampleController.java 파일 추가 

--- 로그인과 로그아웃 처리 
시큐리티의 내부 구조는 복잡하지만 실제 사용은 약간의 설정만으로도 사용가능하다. 

- 접근제한설정 
security-context.xml 에 제한 설정 
<security:intercept-url pattern="/sample/all" access="permitAll"/> .... 

- 접근제한 메시지 처리 
security-context.xml 에 설정 
<security:access-denied-handler error-page="/accessError"/>
CommonController.java
accessError.jsp

- 접근제한시 다양한 처리를 하고 싶다면 . 
AccessDeniedHandler 인터페이스를 구현해 사용한다. 
예를들어 쿠키나 세션에 특정한 작업을 하거나 , 헤더정보를 추가하는 등의 행위를 할경에 직접 구현방식을 권장한다. 
예제 ) CustomAccessDeniedHandler.java 
security-context.xm 의 빈 추가와 아래내용 추가로인해 이전과 달리 accessError 로 리다이렉트 되는걸 볼수 있다. 
<bean id="customAccessDenied" class="org.zerock.security.CustomAccessDeniedHandler"></bean>
<security:form-login login-page="/customLogin" />

- 커스텀 로그인 페이지 
기본적으로 로그인페이지 제공은 하지만 , 테스트용일 뿐이다. 
- 내용 추가 (security-context.xml)
<!--  <security:form-login /> -->
<security:form-login login-page="/customLogin" />
CommonController.java
customLogin.jsp

- CSRF 공격과 토큰 
서버에서 페이지 이동시 새로운 토큰값을 전달해서 가지고 있다가 요청시 서버에 다시 주면서 검증을 하기 때문에 다른 페이지에서 오는 공격을 차단할수 있다.

- 스프링시큐리티의 CSRF 설정
보통은 기본적으로 설정 돼 있지만 비활성화 설정도 가능하다. 

- 로그인 성공후 특정동작 제어 
CustomLoginSuccessHandler.java
빈으로 등록 (security-context.xml)
<bean id="customLoginSuccess" class="org.zerock.security.CustomLoginSuccessHandler"></bean>
핸들러로 지정 
<security:form-login login-page="/customLogin" authentication-success-handler-ref="customLoginSuccess" />
로그인 하는 사용자에 따라서 다른 페이지로 가는것을 볼 수 있다. 

- 로그아웃 처리
로그인과 마찬가지로 로그아웃 처리도 로직처리를 할수 있다. 
<security:logout logout-url="/customLogout" invalidate-session="true" />
CommonController.java
customLogout.jsp
admin.jsp 페이지에 logout 추가해서 테스트 












  












































 











- 프로젝트 실행 점검
프로젝트 우클릭 후 Rus as - Run On Server 선택을 해서 
Hello world! 와 같이 프로젝트 실행이 되는지 확인 한다.
* STS4 에서는 기본으로 제공되는 server 가 없다.

- jdk 버전의 처리
프로젝트 우클릭 후 project facets 에서 자바의 버전을 변경 , 
java Compiler 의 메뉴에서도 자바의 버전을 변경 한다.
* 교제는 jdk1.8을 기준으로 한다.
project Facets , Java Compiler 에서 변경



- 프로젝트 템플릿의 구조
src/main/java : 개발되는 java의 코드경로
src/main/resources : 서버가 실행될 때 필요한 파일들의 경로
src/test/java : 테스트 전용 경로 
src/test/resources : 테스트 시에만 사용되는 파일들 경로
\src\main\webapp\WEB-INF\views : jsp 파일의 경로
\src\main\webapp\WEB-INF\spring : 스프링관련 모든 중요 설정들어가는 곳

- spring 프레임워크의 버전 변경
pom.xml 파일 수정 : 
<java-version>1.8</java-version>
<org.springframework-version>4.1.7.RELEASE</org.springframework-version>
위와같이 수정을 하면 maven 은 새로운 라이브러리를 다운 받는다. Maven Dependencies 에서
스프링 버전이 다운 받아졌는지 확인한다.

- tomcat 9 설치 및 사용
http://tomcat.apache.org/ 에서 다운 후 
sever 에서 Apache Tomcat 을 추가 한다. preferences 에서 server - add 해준 후
프로젝트 우클릭 후 Rus as - Run On Server 선택을 해서 Manually define a new server 선택 후
Tomcat 9 선택 후 실행하면 시작 되는것을 확인할수 있다. (기존의 스프링 기본서버는 stop 한다.)
예제의 경우 페키지의 경로가 'org.zerock.web' 이기 때문에 브라우저상의 경로는 'http://localhost:8080/web/' 된다.

 -  server.xml 의 get 방식을 utf 로 수정
<Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" 
    URIEncoding="UTF-8" />

***************************** 오라클과 spring 테스트 *****************************

- 오라클 ojdbc6 추가하기

보통은 pom파일 열어서 dependency에만 추가해도 되지만 ojdbc같은 경우 
oracle과 메이븐사이의 라이센스 문제 때문에 메이븐 중앙저장소에서 못받는다고 한다.
dependency에만 추가할 경우 아래와 같은 오류 메시지가 뜨니 repository도 함께 pom 파일에 추가해준다.
pom.xml 파일을 연 후에 repository와 dependency 2군데 추가한다. 

<repositories>
		 <!-- repositories 제일 밑에 아래의 repository 추가 -->
		<!-- 오라클 repositories -->	
		<repository>
			<id>oracle</id>
			<url>http://maven.jahia.org/maven2</url>
		</repository>
</repositories>
 
<dependencies>
		<!-- 스프링에서 JDBC 를 사용하기 위한 라이브러리 입니다. -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-jdbc</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
		<!-- 컨넥션 풀을 위한 라이브러리 -->
		<dependency>
			<groupId>commons-dbcp</groupId>
			<artifactId>commons-dbcp</artifactId>
			<version>1.4</version>
		</dependency>
		<!-- 오라클 JDBC 드라이버 -->
		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<version>12.1.0.2</version>
		</dependency>
		<!-- MyBatis 라이브러리 -->
		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis</artifactId>
			<version>3.4.1</version>
		</dependency>
		<!-- 마이바티스와 스프링 연동을 위한 라이브러리 -->
		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis-spring</artifactId>
			<version>1.3.0</version>
		</dependency>
		<!-- 스프링 TEST 위한 라이브러리 -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
</dependencies>
 
- junit 버전 변경
		<!-- Test -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>

\ex00_ora\src\test\java\org\zerock\web\OracleConnectionTest.java
로 커넥션 테스트한다. (junit test 실행)

************* 스피링 + 마이바티스 + mysql 의 설정 *************

- Spring project 에서 root-context.xml 파일 수정

\src\main\webapp\WEB-INF\spring\root-context.xml : 파일수정 , namespaces 클릭 후 
aop , beans , context , jdbc , mybatis 클릭 후 저장하면 root-context.xml 의 내용이 자동으로 추가된다.

- DataSource 설정
root-context.xml 파일에 아래와 같이 추가한다. (root-context.xml 에서 beans 사이에 추가해 주면 된다.)

	<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"></property>
		<property name="url" value="jdbc:oracle:thin:@localhost:1521:orcl"></property>
		<property name="username" value="system"></property>
		<property name="password" value="1111"></property>
	</bean>
	
	<bean id="sqlSessionFactory"
		class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource"></property>
	</bean>

 - DataSource 테스트 해보기 

 \src\test\java\org\zerock\persistence\DataSourceTests.java : 파일만들어서 확인해 보기 ( 우클릭 Run as - junit Test 로 실행 )


 - mybatis-config.xml 파일 추가하기 

 - MyBatis 연결 테스트
 
 - root-context.xml 에 내용추가 (root-context2.xml)

 <bean id="sqlSessionFactory" 
      class="org.mybatis.spring.SqlSessionFactoryBean">
 	<property name="dataSource" ref="dataSource" />
	<property name="configLocation" 
				value="classpath:/mybatis-config.xml"></property>
	</bean>  
 
 ex00\src\test\java\org\zerock\web\MyBatisTest.java  : 파일만들어서 확인해 보기 ( 우클릭 Run as - junit Test 로 실행 )
  



******************** 기본적인 void 리턴 타입 (기초적인 컨트롤러 생성 실습)

서버가 실행이 안될때가 있다. 그럴때는 
프로젝트 우클릭 -> properties -> Deployment Asse.. -> Add -> java build Path Entries -> Maven Dependencies 추가

- servlet-context.xml 주요부분
 MVC 컨트롤러 실행에 있어 가장 중요한 정보가 담겨 있다. MVC 설정만을 분리하기 위해 만들어진 파일이다.
 파일내에 <context:component-scan base-package="org.zerock.controller" /> 이부분은 컨트롤러에서 자동인식 되도록 설정하는 부분이다.

ex00\src\main\webapp\WEB-INF\spring\appServlet\servlet-context.xml 파일에 자동으로 jsp 위치와 jsp 파일로 연결되도록 설정되 있다.

@Controller : 컨트롤러 객체임을 선언하는 애노테이션 
ex00\src\main\java\org\zerock\web\SampleController.java

******************** 기본적인 String 리턴 타입 (기초적인 컨트롤러 생성 실습)

http://localhost:8080/web/doC?msg=jyp
ex00\src\main\java\org\zerock\web\SampleController2.java

******************** 기본적인 String 리턴 타입 (VO값 전달)

http://localhost:8080/web/doD
ex00\src\main\java\org\zerock\web\SampleController3.java

******************** 기본적인 redirect , forward 기능

http://localhost:8080/web/doE
ex00\src\main\java\org\zerock\web\SampleController4.java

******************** 기본적인 JSON 기능

- JSON 데이터를 생성하는 경우
		 pom.xml 에 내용 추가  
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.8.4</version>
		</dependency>

http://localhost:8080/web/doJSON
ex00\src\main\java\org\zerock\web\SampleController5.java

----------- 테이블 생성 및 개발 준비 ----------- 기본적인 흐름에 대한 이해

create table tbl_member ( 
userid varchar2(50) not null,
userpw varchar2(50) not null,
username varchar2(50) not null,
email varchar2(100) not null,
regdate DATE DEFAULT sysdate,
updatedate DATE DEFAULT sysdate,
primary key(userid)
);

도메인 객체를 위한 클래스설계 (VO)

src\main\java\org\zerock\domain\MemberVO.java
ex00\src\main\java\org\zerock\persistence\MemberDAO.java
ex00\src\main\resources\mappers\memberMapper.xml

root-context.xml 에서 Mapper 인식 (root-context3.xml)

<property name="mapperLocations" 
value="classpath:mappers/**/*Mapper.xml"></property>

마이바티스와 스프링 연결을 도와주는 session 추가 (root-context3.xml)

<bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate" 
   destroy-method="clearCache">
  <constructor-arg name="sqlSessionFactory" 
    ref="sqlSessionFactory"></constructor-arg>
</bean>

스피링에 빈으로 등록하기 (root-context3.xml)

<context:component-scan base-package="org.zerock.persistence">
</context:component-scan>

구현 클래스 작성하기
ex00\src\main\java\org\zerock\persistence\MemberDAOImpl.java

테스트 코드의 작성
src\test\java\org\zerock\web\MemberDAOTest.java

mybatis 의 log 를 위한 pom.xml 추가

<dependency>
  <groupId>org.bgee.log4jdbc-log4j2</groupId>
  <artifactId>log4jdbc-log4j2-jdbc4</artifactId>
  <version>1.16</version>
</dependency>

로그관련 설정 위해서 아래의 파일 추가
\src\main\resources\log4jdbc.log4j2.properties
ex00\src\main\resources\logback.xml

was 없이 테스트 가능하게 pom 에 추가
<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>3.1.0</version>
		</dependency>
 
 
src\test\java\org\zerock\web\MemberDAOTest.java 로 테스트 해보기
select * from TBL_MEMBER; 



********************** part 2 , 기본적인 기능의 게시물 관리 (기본적인 CRUD 와 검색처리 기능 ) ******************

ex01) org.zerock.controller -> project 생성 해야한다. 
하지만 기본적인 설정의 ex00과 같기 때문에 복사해서 사용한다.

- 테이블 생성작업

CREATE SEQUENCE seq_tbl_board
    MINVALUE 1
    NOMAXVALUE
    INCREMENT BY 1
    START WITH 1
    CACHE 20
    NOORDER
    NOCYCLE ;
   
   CREATE TABLE tbl_board (   
    bno NUMBER NOT NULL, 
    title VARCHAR2(200) NOT NULL, 
    content CLOB, 
    writer VARCHAR2(50) NOT NULL,  
    regdate DATE DEFAULT sysdate, 
    viewcnt NUMBER DEFAULT 0 ,     
    CONSTRAINT tbl_board_PK PRIMARY KEY (bno)
    );
    
    select * from tbl_board ;
   
   
  - 스프링의 UTF-8 처리 필터 등록하기 (web.xml)
  
  <filter>
	  <filter-name>encoding</filter-name>
	  <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
	  <init-param>
	   <param-name>encoding</param-name>
	   <param-value>UTF-8</param-value>
	  </init-param>
	</filter>
	
	<filter-mapping>
	  <filter-name>encoding</filter-name>
	  <url-pattern>/*</url-pattern>
	</filter-mapping>
	
	
  - bootStrap 를 사용하기 위해서 폴더들을 복사해 준다.
  
  bootstrap , dist, plugins , include 폴더를 필요한 위치에복사 
  home 를 수정한다. (home)이 기본 페이지로 설정돼 있기 때문..
  
  http://localhost:8080/ 를 통해서 boostrap 화면 나오는지 확인



 
  ------------ 영속 계층 , 비즈니스 계층 구현
  
  - org.zerock.domain , org.zerock.service 패키지 복사 (vo 객체 등등..)
  
  - root-context.xml 에 scan 추가
   
  <context:component-scan
		base-package="org.zerock.service">
	</context:component-scan>
  
  - boardMapper.xml 쿼리 추가
  
  - BoardDAOTest 를 통해서 테스트 해본다.
  
  - mybatis-config.xml 에 typeAliases 적용 하면 간편하게 resultType 를 가지고 올수 있다.
  
  <typeAliases>
    <package name="org.zerock.domain"/>    
  </typeAliases>
  
  ------------ 실직적인 등록 구현 
  
  - org.zerock.controller 패키지 복사 (controller 등등 ..)
  
   - board 폴더를 views 에 복사 한다. (jsp 필요 파일들)
   
   - tomcat 을 통해 /board/register 를 호출해본다. (get 방식)
   
    register.jsp 에서 form 의 action 이 지정되지 않았으며 , 속성또한 post 가 아니다. 
	이럴때는 현재의 경로를 그대로 action 의 대상 경로로 잡게 된다.
	
	등록이 완료되면 , success.jsp 로 자동 이동된다.
	이때 새로고침을 통해 post 방식이 다시 호출 될수 있으므로 controller 에서 redirect 설정을 해준다.
   
   - listAll.jsp 테스트 한다.
   <%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%>
   를 추가해서 , JSTL 을 사용할수 있도록 한다.
   
   - read.jsp , 삭제처리 , 수정처리까지(modify.jsp) 완료한다.
   
   
   ------------ 예외 처리
   
  @ExceptionHandler 을 통해서 예외처리를 한다.
  CommonExceptionAdvice.java , error_common.jsp 에 예외처리를 하면된다.


   
   ------------ 페이징 처리   
	
   충분한 양의 데이터 넣기 : insert .. 해서 데이터를 넣는다.
	insert into tbl_board (bno, title, content , writer)
     (select seq_tbl_board.NEXTVAL, title, content, writer from tbl_board);
	
   http://localhost:8080/board/listPage 로 테스트 하기


   ------------ 검색처리와 동적 SQL (이후부터는 sboard 를 통해 진행된다.)
   
   SearchCriteria.java 를 추가한다. (Criteria 상속)
   SearchBoardController.java 추가
   views 에 sboard 폴더추가
   
   encoding 처리를 해줘야 한다. jsp (encodeURIComponent) , java (PageMaker, URLEncoder.encode(keyword,"UTF-8"))
   
   
   
   
   
   ********************** part 3 "ajax 댓글 처리"  , Rest방식의 이해, Ajax 방식의 이해, json 데이터처리 , handlebars 를 이용한 템플릿 처리 ******************
    - JSON 사용하려면 pom.xml 에 추가
	<!-- json 라이브러리 -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>2.8.4</version>
		</dependency>
  
  - SampleController.java , SampleVO.java 를 추가해서 테스트를 해본다.
   @RestController 를 사용하면 , 응답을 문자열 또는 json 으로 할 수 있다.
   
   http://localhost:8080/sample/hello -> 문자열
   http://localhost:8080/sample/sendVO -> json
   http://localhost:8080/sample/sendList -> list 
   
   
   - Rest client 설치
   https://chrome.google.com/webstore
   Advanced REST client 설치 
   
   - 댓글을 위한 테이블 생성
	
	CREATE SEQUENCE seq_tbl_reply
    MINVALUE 1
    NOMAXVALUE
    INCREMENT BY 1
    START WITH 1
    CACHE 20
    NOORDER
    NOCYCLE ;

	CREATE TABLE tbl_reply (   
    rno NUMBER NOT NULL, 
    bno NUMBER DEFAULT 0 NOT NULL,
    replytext CLOB NOT NULL,
    replyer VARCHAR2(50) NOT NULL,  
    regdate DATE DEFAULT sysdate, 
    updatedate DATE DEFAULT sysdate,     
    CONSTRAINT tbl_reply_PK PRIMARY KEY (rno)
    );
	
	ALTER TABLE tbl_reply ADD CONSTRAINT fK_board FOREIGN KEY(bno)
	REFERENCES tbl_board(bno);

	
	- 댓글을 위한 vo , dao , mapper 등등 생성
	ReplyVO.java , ReplyDAO.java , replyMapper.xml , ReplyDAOImpl.java , ReplyService.java , ReplyServiceImpl.java , ReplyController.java
	
	- Advanced REST client 로 등록 테스트
	http://localhost:8080/replies (post)
	headers : Content-Type application/json
    {"bno":"24580","replyer":"testUser","replytext":"테스트댓글1"}
	{"bno":"24580","replyer":"testUser","replytext":"테스트댓글2"}

	
	- Advanced REST client 전체 댓글 불러오는지 테스트한다.
	http://localhost:8080/replies/all/24580 (get)

	- Advanced REST client 수정 테스트한다.
	http://localhost:8080/replies/2 (petch , put)
	{"replytext":"수정된 댓글 추가"}
	
	- 브라우저의 종류에 따라서 , PUT , PATCH , DELETE 같은 방식을 지원하지 않는경우도 있다.
	그런 상황의 고려를 위해서 web.xml 에 아래의 내용을 추가한다.
	
	<filter>
		<filter-name>hiddenHttpMethodFilter</filter-name>
		<filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>hiddenHttpMethodFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	
	설정 후 에는 POST 방식으로 진행하고 , method 를 추가한 상태에서 진행하면 된다.
	
	
	- Advanced REST client 삭제처리 테스트한다.
	http://localhost:8080/replies/2 (delete)
	
	
	-------- 화면에서의 Ajax 호출 -------------------------
	
	- 테스트를 위해서 HomeController.java 에 아래와 같이 추가해준다.

	@RequestMapping(value = "/test", method = RequestMethod.GET)
		public void ajaxTest() {
	}
	
	
	- test.jsp 추가
	http://localhost:8080/test
	CRUD 를 테스트 해본다. 

	
	-------- 게시물 관리의 댓글 적용 -------------------------

	- readPage.jsp 수정한다. 

	- handlebars 사용 연습
	http://localhost:8080/resources/ex00.html
	http://localhost:8080/resources/ex01.html
	http://localhost:8080/resources/ex02.html


    - 실제 화면에서 댓글을 테스트 해본다.

	http://localhost:8080/sboard/list
	
	
	
   
   ********************** part4 AOP 와 트랜잭션 처리 (ex03) *****************
   
   - pom 에 추가
   
   <dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-aop</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
		
	<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-tx</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>

	<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjtools</artifactId>
			<version>${org.aspectj-version}</version>
		</dependency>

	- root-context.xml 에 Namespace 에 tx 체크해준다. 아래의 내용도 추가해 준다.

	<aop:aspectj-autoproxy></aop:aspectj-autoproxy>

	<context:component-scan base-package="org.zerock.aop"></context:component-scan>

	<aop:config>
	</aop:config>	

	
	- 샘플용 테이블 설계
    
CREATE TABLE tbl_user (   
    uid1 VARCHAR2(50) NOT NULL ,  
     upw1 VARCHAR2(50) NOT NULL , 
     uname1 VARCHAR2(100) NOT NULL , 
     upoint1 NUMBER DEFAULT 0 ,
    CONSTRAINT tbl_user_PK PRIMARY KEY (uid1)
    );


insert into tbl_user(uid1, upw1, uname1) values ('user00','user00','IRON MAN');
insert into tbl_user(uid1, upw1, uname1) values ('user01','user01','CAPTAIN');
insert into tbl_user(uid1, upw1, uname1) values ('user02','user02','HULK');
insert into tbl_user(uid1, upw1, uname1) values ('user03','user03','Thor');
insert into tbl_user(uid1, upw1, uname1) values ('user10','user10','Quick Silver');


create table tbl_message (
mid number not null ,
targetid varchar2(50) not null,
sender varchar2(50) not null,
message CLOB not null,
opendate date DEFAULT sysdate,
senddate date default sysdate,
CONSTRAINT tbl_message_PK PRIMARY KEY (mid)
);

CREATE SEQUENCE seq_tbl_message
    MINVALUE 1
    NOMAXVALUE
    INCREMENT BY 1
    START WITH 1
    CACHE 20
    NOORDER
    NOCYCLE ;

alter table tbl_message add constraint fk_usertarget
foreign key (targetid) references tbl_user (uid1);

alter table tbl_message add constraint fk_usersender
foreign key (sender) references tbl_user (uid1);




	- dao , xml , 서비스 생성
	
	MessageVO.java , UserVO.java , MessageDAO.java , MessageDAOImpl.java , messageMapper.xml
	
	PointDAO.java , PointDAOImpl.java , pointMapper.xml , MessageService.java , MessageServiceImpl.java
	
	- AOP 연습하기 , 파일 추가
	
	SampleAdvice.java , MessageController.java
	SampleAdvice.java 가 AOP 의 직접적인 역할을 한다.
	
	log4j.xml -> info 로 수정
	
	- Advanced REST client 로 테스트
	
	(post) http://localhost:8080/messages/
	
	{"targetid":"user01","sender":"user00","message":"Good Luck!"}



    - Spring 트랜잭션 처리 (@Transactional 애노테이션)
	
	- root-context 에 추가
	
	<bean id="transactionManager"
		class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"></property>
	</bean>

	<tx:annotation-driven />
	
	- 트랜잭션 테스트는 생략한다.
	
	---------- 댓글 카운트의 처리 ----------------------------------
	
	
	- BoardVO.java 수정 , boardMapper.xml 수정 , BoardDAO.java 수정 , ReplyDAOImpl.java 수정 , ReplyDAO.java 수정

     - 쿼리 수정
	alter table tbl_board add replycnt number default 0 ;
    
	update tbl_board set replycnt = ( select count(rno) from tbl_reply where bno = tbl_board.bno) where bno >0 ;
	



   ********************** part5 게시물의 첨부파일 기능 (ex04) , ajax 이용한 파일 업로드 , 파일 저장 및 다운로드 *****************
	
	
	- 이미지를 깨끗하게 축소할수 있는 imgScalr 라이브러리 추가 (pom.xml)
	<dependency>
			<groupId>commons-fileupload</groupId>
			<artifactId>commons-fileupload</artifactId>
			<version>1.3.2</version>
		</dependency>

		<dependency>
			<groupId>org.imgscalr</groupId>
			<artifactId>imgscalr-lib</artifactId>
			<version>4.2</version>
		</dependency>
		
	- servlet-context.xml 에 설정추가 , 빈등록과 크기제한
	
	<beans:bean id="multipartResolver"
		class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<beans:property name="maxUploadSize" value="10485760"></beans:property>
	</beans:bean>

  <beans:bean id="uploadPath" class="java.lang.String">
    <beans:constructor-arg value="C:\\spring_file\\upload">
    </beans:constructor-arg>
	
	
	- 일반적인 파일 업로드 이해하기 (테스트)
	
	UploadController.java 추가 , uploadForm.jsp 
	
	http://localhost:8080/uploadForm
	
	만약 한글이름이 깨진다면 , web.xml 에 UTF-8 encoding 설정을 해줘야 한다.
	
	iframe 을 사용하면 , 화면의 전환을 피할수 있다. iframe 부분만 전환
  
	- Ajax 방식의 파일 업로드 , drag & drop 방식을 사용한다. 다중도 가능하지만 예제에서는 단일 파일 업로드를 기준으로 한다.
	
	http://localhost:8080/uploadAjax
	
	-------- 게시물 등록의 파일 업로드 ----------------
	
	- 테이블 만들기
	
	CREATE TABLE tbl_attach (   
    fullname VARCHAR2(150) NOT NULL,  
    bno number NOT NULL,
    regdate timestamp DEFAULT sysdate,    
	CONSTRAINT tbl_attach_PK PRIMARY KEY (fullname)	
    );
	
	ALTER TABLE tbl_attach ADD CONSTRAINT fK_board_attach FOREIGN KEY(bno)
    REFERENCES tbl_board(bno);
	
	- vo , dao , mapper , service 수정
	
	BoardDAO.java , BoardDAO.java , BoardDAOImpl.java , BoardService.java , BoardServiceImpl.java , SearchBoardController.java
	
	register.jsp , upload.js , readPage.jsp
	
	***** 참부파일의 추가 와 조회 가능하지만 ,  삭제 , 수정은 구현돼 있지 않다. 
	
	
	********************** part6 interceptor 를 이용한 로그인 처리 *****************
	
	- filter 와 interceptor 의 차이는 스프링에서 관리되는 모든 객체에 접근이 가능하다는 것 이다.
	
		AOP 와 interceptor 의 차이는 파라미터의 차이다. 
	
	- org.zerock.interceptor 패키지를 생성한다.
	
	- servlet-context.xml 에 인터셉터 설정 (테스트용)
	
	<beans:bean id="sampleInterceptor" class="org.zerock.interceptor.SampleInterceptor"></beans:bean>
  <interceptors>
  <interceptor> 
  <mapping path="/doA"/> 
  <mapping path="/doB"/> 
  <beans:ref bean="sampleInterceptor"/> 
  </interceptor> 
  </interceptors>
  
	- HomeController.java  , SampleInterceptor.java , home.jsp -----  테스트용으로 추가 , 수정
	
	- 테스트를 하면서 log를 확인해 본다. 
	
	http://localhost:8080/doA
  
    preHandle 가 먼저 호출되고, 메소드 동작 후 postHandle 가 작동한다.
   
	- request, response 활용한 interceptor 테스트 
	
	http://localhost:8080/doB
	
	기존의 home.jsp 는 session=false 로 설정 돼 있기 때문에 , 제거 후 테스트 해본다. 
	
	-------------- httpsession 을 이용하는 로그인 처리 ----------------
	
	
	- LoginDTO.java 추가
	
	vo 는 보통 테이블과 같이 설계하고 , dto 는 화면에 가깝게 설계 한다.
	
	- 파일 추가
	
	UserDAO.java
	UserDAOImpl.java
	userMapper.xml
	UserService.java
	UserServiceImpl.java
	UserController.java
	LoginInterceptor.java
	AuthInterceptor.java
	login.jsp
	loginPost.jsp

	- servlet-context 수정 
	
	 <beans:bean id="sampleInterceptor" class="org.zerock.interceptor.SampleInterceptor"></beans:bean>
	<beans:bean id="authInterceptor" class="org.zerock.interceptor.AuthInterceptor"></beans:bean>
	<beans:bean id="loginInterceptor" class="org.zerock.interceptor.LoginInterceptor"></beans:bean>
	<interceptors>
		<interceptor>
			<mapping path="/user/loginPost" />
			<beans:ref bean="loginInterceptor" />
		</interceptor>
 	  <interceptor>
	    <mapping path="/sboard/register"/>
	    <mapping path="/sboard/modifyPage"/>
	    <mapping path="/sboard/removePage"/>
	    <beans:ref bean="authInterceptor"/>
	  </interceptor>	
	</interceptors>
  	
   - 로그인에 맞게 파일 수정
   
   register.jsp
   readPage.jsp
   
   - 테이블 변경
   
   alter table tbl_user add
   sessionkey varchar2(50) default 'none' ;
   
   alter table tbl_user
   add sessionlimit date;

   - logout 테스트
	http://localhost:8080/user/logout 
   
	- 자동로그인 테스트 
	쿠키를 이용해 7일간 자동로그인이 돼도록 설정한다.

	user01 , user02 테스트 아이디 

   - 정리 : 세션폭탄에 대한 대비는 돼있지 않으며 , 스프링 시튜리티 와 암호화는 적용 되지 않았다 . 
   자동로그인이 어떤식으로 구현되는지만 보여주기 위해 작성된 코드이다.
	
	
	
	